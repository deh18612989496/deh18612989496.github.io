{"meta":{"title":"DRH","subtitle":null,"description":null,"author":"JACK","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2019-03-29T12:53:38.000Z","updated":"2019-03-29T12:53:38.765Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"redis","date":"2019-02-28T10:44:24.539Z","updated":"2019-02-28T09:32:04.264Z","comments":true,"path":"2019/02/28/redis/","link":"","permalink":"http://yoursite.com/2019/02/28/redis/","excerpt":"","text":"1.安装redis123456789 [root@iZwz97tbgo9lkabnat2lo8Z ~]# wget http://download.redis.io/releases/redis-3.2.12.tar.gz[root@iZwz97tbgo9lkabnat2lo8Z ~]# gunzip redis-3.2.12.tar.gz[root@iZwz97tbgo9lkabnat2lo8Z ~]# tar -xvf redis-3.2.12.tar[root@iZwz97tbgo9lkabnat2lo8Z ~]# cd redis-3.2.12[root@iZwz97tbgo9lkabnat2lo8Z ~]# make &amp;&amp; make install[root@iZwz97tbgo9lkabnat2lo8Z ~]# redis-server --versionRedis server v=3.2.12 sha=00000000:0 malloc=jemalloc-4.0.3 bits=64 build=5bc5cd3c03d6ceb6[root@iZwz97tbgo9lkabnat2lo8Z ~]# redis-cli --versionredis-cli 3.2.12 2.修改配置文件3.启动redis####1.启动redis服务器redis-server redis.conf – 启动redis服务redis-server redis.conf &amp; – 启动redis服务并且在后台运行redis-server redis.conf &gt;&gt; redis.log &amp; – 启动redis服务并且在后台运行,并且输出重定向 ####2.启动redis客户端redis-cli -h ip地址 4.redis指令123456789101112131415161718192021----字符串常用操作 set key value -- 添加键值对、如果key存在就修改key对应的值 setnx key value -- 如果key不存在就添加键值对setex key 时间 value -- 添加键值对并且设置存活时间 set key value ex 时间 -- 添加键值对并且设置超时时间 mset key1 value1 key2 value2 ... -- 同时添加多个键值对mget key1 key2 ... --同时获取多个key的值 get key -- 查看key对应的值 keys * -- 查看所有的key del key1 key2 -- 删除键值对 exists key -- 检测键值对是否存在 flushall -- 删除所有数据库的所有键值对 flushdb -- 删除当前数据库中所有键值对 select 标号 -- redis默认启动16个数据库对应的标号是0-15 ttl key -- 查看剩余时间 expire key 时间 -- 设置键值对存活时间 incr key -- 数值增加1 decr key -- 数值减少 append key 值 --key对应的字符串类型的值后追加指定的值 quit -- 退出","categories":[],"tags":[]},{"title":"AB压力测试(同步，异步测试)","slug":"AB压力测试(同步，异步测试)","date":"2019-02-23T02:41:49.681Z","updated":"2019-03-30T10:06:41.872Z","comments":true,"path":"2019/02/23/AB压力测试(同步，异步测试)/","link":"","permalink":"http://yoursite.com/2019/02/23/AB压力测试(同步，异步测试)/","excerpt":"","text":"#同步测试(一直执行一个一直等到执行完) #测试前将cmd ，cd到安装有ab的文件的整个目录下 #要用pip install tornado==4.5（在terminal下输入卸载：pip uninstall tornado） #sync_tornado.py 123456789101112131415161718192021222324252627import tornado.webimport tornado.ioloopimport tornado.httpclientclass IndexHandler(tornado.web.RequestHandler): def get(self): # 路由中传递的参数，/index/?q=python q = self.get_argument(&apos;q&apos;) # 向地址发送请求: https://cn.bing.com/search?q= client = tornado.httpclient.HTTPClient() response = client.fetch(&apos;https://cn.bing.com/search?q=%s&apos; % q) print(response) self.write(&apos;同步测试&apos;)def make_app(): return tornado.web.Application(handlers=[ (r&apos;/index/&apos;, IndexHandler), ])if __name__ == &apos;__main__&apos;: app = make_app() app.listen(8000) tornado.ioloop.IOLoop.current().start() #异步：会有一个装饰机器让连接不会断掉，并且同时执行多个连接. #aync_tornado.py123456789101112131415161718192021222324252627282930import tornado.webimport tornado.ioloopimport tornado.httpclientclass IndexHandler(tornado.web.RequestHandler): @tornado.web.asynchronous def get(self): q = self.get_argument(&apos;q&apos;) client = tornado.httpclient.AsyncHTTPClient() client.fetch(&apos;https://cn.bing.com/search?q=%s&apos; % q, callback=self.on_response) self.write(&apos;异步测试&apos;) def on_response(self, response): # 回调，当页面响应，则调用回调函数on_response print(response) self.write(&apos;回调执行&apos;) self.finish()def make_app(): return tornado.web.Application(handlers=[ (r&apos;/index/&apos;, IndexHandler), ])if __name__ == &apos;__main__&apos;: app = make_app() app.listen(8080) tornado.ioloop.IOLoop.current().start() #aync_tornado2.py(异步镶嵌异步一般不用比较繁琐)1234567891011121314151617181920212223242526import tornado.webimport tornado.ioloopimport tornado.httpclientclass IndexHandler(tornado.web.RequestHandler): @tornado.web.asynchronous @tornado.web.gen.coroutine def get(self): q = self.get_argument(&apos;q&apos;) client = tornado.httpclient.AsyncHTTPClient() response = yield client.fetch(&apos;https://cn.bing.com/search?q=%s&apos; % q) print(response) self.write(&apos;异步测试&apos;)def make_app(): return tornado.web.Application(handlers=[ (r&apos;/index/&apos;, IndexHandler), ])if __name__ == &apos;__main__&apos;: app = make_app() app.listen(8090) tornado.ioloop.IOLoop.current().start()","categories":[],"tags":[{"name":"标签","slug":"标签","permalink":"http://yoursite.com/tags/标签/"}]},{"title":"","slug":"vim编辑器之神","date":"2019-02-22T10:42:15.436Z","updated":"2019-02-23T02:37:31.667Z","comments":true,"path":"2019/02/22/vim编辑器之神/","link":"","permalink":"http://yoursite.com/2019/02/22/vim编辑器之神/","excerpt":"","text":"vim编辑器之神配置vimrc配置在shell中可以通过 vim ~/.vimrc 或者 vim /etc/vimrc 打开vimrc文件对vim进行配置。在这个文件中可以进行很多和vim相关的配置，常用的如下（如果对其他配置感兴趣的可以自己百度）： 常用操作1.模式切换我们可以将vim分为命令模式、编辑模式和末行模式三种命令模式：进入vim的时候vim是处于命令模式状态下的，这个时候输入内容不会出现在编辑区 (最末什么都没有) 末行模式：在命令模式下输入冒号，让vim进入末行模式。在末行模式的冒号后面可以输入相关的一些指令进行相关操作 (最后有一个冒号) 编辑模式：在命令模式下按’i’进入编辑模式。在编辑模式下可以对文件内容进行编辑 (最后 –INSERT– 或者 –插入–) ####2.保存和退出在末行模式下输入相应的指令可以对编辑区的内容进行保存和退出vim界面w – 只保存(类似快捷键ctr+s)q – 退出（在编辑区的内容全部都保存的情况下才有效）wq – 保存并退出q! – 强制退出（不保存修改信息） ####3.光标操作以下光标操作都是在命令模式下输入的^(shift+6) – 移动到行首$(shift+4) – 移动到行尾G(shift+g) – 移动到文件末尾行号G – 移动到指定行,例如:30G, 让光标直接跳转到行号是30的那一行gg – 移动到文件开头 ####4.文本操作以下操作不带冒号的是在命令模式下输入，前面有冒号代码后面的内容是在末行模式下输入dd – 删除光标所在的行数字dd – 从光标所在行开始往后面开始删，删除指定数量行内容:%d – 删除所有 yy – 复制光标所在的行数字yy – 从光标所在行开始复制指定行数的内容p – 将复制的内容粘贴到光标所在的位置u – 撤销ctr+r – 反撤销 :%!sort – 对内容排序 :/查找对象[/gice] – 搜索匹配正则表达式的内容，按回车回到命令模式后按n往前查找，按N往后查找 *:1,$s/被替换对象/替换内容[/gice]* – 将正则表达式匹配到的内容替换成指定内容 - g: 全局匹配 - i: 忽略大小写 - c: 替换时需要提示 - e: 忽略错误","categories":[],"tags":[]},{"title":"","slug":"Nginx服务器安装","date":"2019-02-22T10:42:15.435Z","updated":"2019-02-23T02:39:14.821Z","comments":true,"path":"2019/02/22/Nginx服务器安装/","link":"","permalink":"http://yoursite.com/2019/02/22/Nginx服务器安装/","excerpt":"","text":"Nginx服务器1.阿里云添加80端口阿里云上默认只有一个22端口用来做远程登录，如果希望在阿里云上安装支持http请求的nginx服务器，需要给阿里云添加80端口 2. 安装nginxa) 添加nginx存储库 1yum install epel-release b) 安装nginx 1234 yum install nginx``` c) 运行nginx Nginx不会自行启动。要运行Nginx systemctl start nginx 12nginx的运行命令: systemctl status nginx 查看nginx的状态 systemctl start/stop/enable/disable nginx 启动/关闭/设置开机启动/禁止开机启动 12d) 系统启动时启动Nginx systemctl enable nginx 12e）如果您正在运行防火墙，请运行以下命令以允许HTTP和HTTPS通信： sudo firewall-cmd --permanent --zone=public --add-service=http sudo firewall-cmd --permanent --zone=public --add-service=https sudo firewall-cmd --reload 12345### 3.nginx目录共享配置 a) 在contOS目录中确定一个需要共享的文件夹，例如： /home/yuting b) 打开 etc/nginx/nginx.conf 文件，设置server #共享设置 - 在浏览器中输入服务器ip地址，会展示共享目录的文件列表 root /home/yuting; location / { autoindex on; autoindex_exact_size on; autoindex_localtime on; } 12除了可以共享文件，还可以自定义页面 #自定义服务器页面 location / { root /home/yuting; index index.html index.htm; } ` 注意： 如果出现权限问题，可以修改目录的权限 ssh密钥认证1.在主机和从机上执行：ssh-keygen 2.在从机上执行: scp id_rsa.pub root@主机地址:~/.ssh/master.pub(上面这条指令是将从机上的 id_rsa.pub文件拷贝传递给到主机的.ssh文件夹下，并且命名为’master.pub’) 3.在主机中的.ssh文件夹中创建authorized_keys文件： touch authorized_keys 4.修改文件authorized_keys的权限: chmod 600 authorized_keys 5.将master.pub放进authorized_keys文件中: cat master.pub &gt;&gt; authorized_keys 6.在操作主机的时候，需要主机能够自己免密访问自己就将自己的公钥放在自己的authorized_keys文件中","categories":[],"tags":[]},{"title":"日志的搭建（日志就是能把错误收集在一起的.log）","slug":"日志搭建","date":"2019-02-22T10:42:15.433Z","updated":"2019-03-30T10:10:43.993Z","comments":true,"path":"2019/02/22/日志搭建/","link":"","permalink":"http://yoursite.com/2019/02/22/日志搭建/","excerpt":"","text":"#day04/setting.py(在最下面 的setting.py加入下面代码)12345678910111213141516171819202122232425262728293031323334# 日志配置LOG_PATH = os.path.join(BASE_DIR, &apos;logs&apos;)LOGGING = &#123; # 必须为1 &apos;version&apos;: 1, # 禁用日志 &apos;disable_existing_loggers&apos;: False, &apos;loggers&apos;: &#123; &apos;&apos;: &#123; # 将系统接收到的日志，交给handler去处理 &apos;handlers&apos;: [&apos;console&apos;], &apos;level&apos;: &apos;INFO&apos;, &#125; &#125;, &apos;handlers&apos;: &#123; &apos;console&apos;: &#123; # handler将日志信息存放在day07/logs/sys.log &apos;filename&apos;: &apos;%s/%s&apos; % (LOG_PATH, &apos;sys.log&apos;), &apos;level&apos;: &apos;INFO&apos;, # 指定日志的格式 &apos;formatter&apos;: &apos;default&apos;, # 备份 &apos;class&apos;: &apos;logging.handlers.RotatingFileHandler&apos;, # 日志文件大小: 5M &apos;maxBytes&apos;: 5 * 1024 * 1024, &#125; &#125;, &apos;formatters&apos;:&#123; &apos;default&apos;: &#123; &apos;format&apos;: &apos;%(asctime)s %(message)s&apos; &#125; &#125;&#125; #并在上面的文件MIDDLEWARE 里面加1&apos;utils.LogMiddleware.LogMiddle&apos;, #utils/LogMiddleware.py123456789101112131415161718192021222324252627282930313233343536import loggingimport timefrom django.utils.deprecation import MiddlewareMixin# 获取日志loggerlogger = logging.getLogger(__name__)class LogMiddle(MiddlewareMixin): # 日志处理中间件 def process_request(self, request): # 存放请求过来时的时间 request.init_time = time.time() return None def process_response(self, request, response): try: # 请求响应时，耗时时长 total_time = time.time() - request.init_time # 请求路径 path = request.path # 请求方式 method = request.method # 响应状态码 status_code = response.status_code # 响应内容 content = response.content # 记录信息 message = &apos;%s %s %s %s %s&apos; % (total_time, path, method, status_code, content) logger.info(message) except: logger.critical(&apos;系统错误&apos;) return response #日志级别等级CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG &gt; NOTSET","categories":[],"tags":[]},{"title":"Linux","slug":"Linux指令系统","date":"2018-09-30T09:25:30.000Z","updated":"2019-02-23T02:43:50.408Z","comments":true,"path":"2018/09/30/Linux指令系统/","link":"","permalink":"http://yoursite.com/2018/09/30/Linux指令系统/","excerpt":"","text":"Linux指令系统： 命令名称 [命名参数] [命令对象] 一、日常操作1.cd指令 - 进入指定文件夹cd 目录 - 进入指定目录(也可以是文件夹对应的路径) ~相对路径 — 绝对路径 cd .. - 返回上层目录cd ~ - 回到根目录 ls指令 - 查看当前目录中的内容lsls -l/-lhls -a - 隐藏文件也一起显示ls -R - 递归显示所有内容ls -S/-t - 按大小/时间排序 3.pwd指令 - 显示当前完整目录pwd 4.文件操作指令touch 文件名 - 新建文件cat 文件名 - 查看文件内容 rm 文件名 - 删除文件rm - r 目录 - 删除文件夹 cp 文件名1 文件名2 - 将文件1中的内容拷贝到文件2中cp -r 文件名/目录名 目录2 - 将文件/目录拷贝到目录2中 mv 文件名1 文件名2 - 将文件1中的内容移动到文件2中 ,并且删除文件1（文件重命名）mv 文件名1 文件目录 - 将文件1移动到指定目录中 (注意：cp/mv/rm 后面可以跟： -i询问 -f强制 -n不覆盖) mkdir 目录名 - 新建文件夹mkdir -p a/b/c - 按层级创建a,b,c三个文件夹mkdir -p a/{b,c}/{d,e,f} -同一层级常见多个 rmdir 目录名 - 删除指定空目录 7.history - 显示历史指令记录bashrc 配置显示时间：export HISTTIMEFORMAT=”[%y‐%m‐%d_%T] “修改bashrc 后使其生效: source ~/.bashrc 或 . .bashrc 6.链接ln -s 源路径 目标路径 - 给源路径对应的文件在目标路径下创建一个软链接(可以看成是快捷键)ln 源路径 目标路径 - 给源路径对应的文件在目标路径下创建一个硬链接 8.快捷键ctr + f - 前进一个字符ctr + b - 后退一个字符ctr + a - 回到行首ctr + e - 回到行尾ctr + w - 向左删除一个单词ctr + u - 向左删除全部ctr + k - 向右删除全部ctr + y - 粘贴上次删除的内容ctr + l - 清屏 二、进程相关指令1.ps指令ps - 进程状态ps -aux 或者 ps ex - 查看进程ps -aux|grep 进程名 - 查看指定进程psgrep 进程名 2.top指令top - 动态监控进程top -p PID1,PID2,…. - 动态监控指定进程 3.free指令free -单位 - 以指定单位查看内存 4.kill指令 kill 进程号 - 杀死指定的进程kill -1/-9/-15 - -1(HUP)不间断重启，-9(KILL)强制杀死进程,-15(TERM)正常终止进程pkill 进程名 - 按名字处理进程killall 进程名 - 处理名字匹配的进程 uptime - 查看系统状态 三、权限管理1.user和group users -查看当前用户groupadd 分组名 - 添加分组useradd ‐G 分组列表 ‐m ‐s /bin/bash 用户名 - 创建一个用户添加到指定的分组中usermod -G 分组列表 用户名 - 修改分组sudo - 以管理员执行其他程序su - 用户名 - 切换用户身份","categories":[],"tags":[]},{"title":"git常用指令","slug":"git常用指令","date":"2018-09-30T09:25:30.000Z","updated":"2019-02-23T02:47:27.146Z","comments":true,"path":"2018/09/30/git常用指令/","link":"","permalink":"http://yoursite.com/2018/09/30/git常用指令/","excerpt":"","text":"git常用指令1.基本指令git init &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —— 新建git仓库git add 文件/文件夹 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —— 将文件添加到缓存区中git add -A &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; — 添加所有内容到缓存区中git stutas &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——— 查看git状态git commit -m ‘提交信息’ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 将缓存区中的内容全部提交到git本地仓库中 git log &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——- 查看提交日志 git reset - - hard HEAD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 让工作目录中的内容和仓库中的内容保持一致git reset --hard HEAD^ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 回到上一个版本git reset - - hard 版本号 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 回到指定的版本git checkout - - 文件名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —— 从暂存区中恢复工作目录中的内容(让工作区中的指定文件，回到上次提交的时候的状态) git clone &lt;url&gt; - 将服务器上的项目(仓库)克隆 (使用https地址需要输入密码，使用ssh地址需要添加公钥) git remote add origin 地址 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—– 关联远程仓库(只需要关联一次) git push [-u] origin master &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—– 提交(-u在第一次提交分之的时候才用) 2.分之管理创建仓库会默认给我们创建一个master分之,这个分之一般作为提交和发布分之;开发一般会自己创建一个develop分之，用来开发和测试;多人协作的时候还可能根据不同的人或者(不同的功能)创建不同的分之，用来独立开发 常见分之： master(主要是合并develop), develop(主要合并下面的其他分支), 功能/人员分之(开发) git branch [-a] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 查看分之git branch 分之名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 创建分之git checkout 分支名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 切换分之git checkout -b 分之名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 切换并创建新的分之git diff 分之1 分之2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 查看两个分之之间的差异git merge 分之名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 让当前分之和指定分之进行合并 注意: 切换分之、push、pull，这些操作前要保证工作区是clean 怎么避免冲突： 不要发生多个分之对同一个文件在同一个版本下进行修改(和同伴确认和商量)","categories":[],"tags":[]},{"title":"Tornado简单的人脸识别","slug":"Tornado利用阿里云实现人脸识别","date":"2018-09-30T09:25:30.000Z","updated":"2019-03-30T10:15:38.117Z","comments":true,"path":"2018/09/30/Tornado利用阿里云实现人脸识别/","link":"","permalink":"http://yoursite.com/2018/09/30/Tornado利用阿里云实现人脸识别/","excerpt":"","text":"#通过百度云的AI开放平台的接口来实现的ai的人脸识别 #安装环境：requirement.txt (pip install -r requirement.txt) 1234pymysqlsqlalchemytornado==4.5baidu-aip #manage.py123456789101112131415161718192021222324252627282930import osimport tornado.webimport tornado.ioloopfrom tornado.options import parse_command_line, options, definefrom face.views import RegisterHandler, InitDbHandler, LogonHandlerdefine(&apos;port&apos;,default=80,type=int)def make_app(): return tornado.web.Application(handlers=[ (r&apos;/register/&apos;,RegisterHandler), (r&apos;/init_db/&apos;, InitDbHandler), (r&apos;/login/&apos;,LogonHandler) ], template_path=os.path.join(os.path.dirname(os.path.abspath(__file__)), &apos;templates&apos;), static_path=os.path.join(os.path.dirname(os.path.abspath(__file__)), &apos;static&apos;), )if __name__ == &apos;__main__&apos;: parse_command_line() app=make_app() app.listen(options.port) tornado.ioloop.IOLoop.current().start() #face/models.py 123456789101112131415from datetime import datetimefrom sqlalchemy import Column,Integer,String,DateTimefrom untils.conn import Basedef init_db(): Base.metadata.create_all()class User(Base): id=Column(Integer,primary_key=True,autoincrement=True) username=Column(String(10), unique=True, nullable=False) realname = Column(String(10), unique=True, nullable=False) create_time = Column(DateTime, default=datetime.now) __tablename__ = &apos;user&apos; #face/views.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import tornado.webfrom face.models import init_db, Userfrom untils.conn import Base, sessionfrom untils.faceid import face_register, face_loginclass RegisterHandler(tornado.web.RequestHandler): def get(self): error=&apos;&apos; self.render(&apos;register.html&apos;, error=error) def post(self): #注册 face=self.get_argument(&apos;face_img&apos;) img = face.split(&apos;,&apos;)[-1] username=self.get_argument(&apos;username&apos;) realname=self.get_argument(&apos;realname&apos;) if face and username and realname: #条用百度接口注册 user=User() user.username = username user.realname = realname session.add(user) session.commit() res = face_register(img,user.id) if res: self.redirect(&apos;/login/&apos;) else: session.delete(user) session.commit() self.redirect(&apos;/register/&apos;) else: error = &apos;请填写完整！&apos; self.render(&apos;register.html&apos;, error=error)class InitDbHandler(tornado.web.RequestHandler): def get(self): #将模型映射到数据库中 #Base.metadata.create_all() init_db() self.write(&apos;创建表成功&apos;)class LogonHandler(tornado.web.RequestHandler): def get(self): self.render(&apos;login.html&apos;) def post(self): face = self.get_argument(&apos;face_img&apos;) img = face.split(&apos;,&apos;)[-1] res = face_login(img) if res: self.write(&apos;成功&apos;) else: self.write(&apos;失败&apos;) #static/js/ai.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182var video = document.querySelector(&apos;video&apos;);var audio, audioType;var canvas1 = document.getElementById(&apos;canvas1&apos;);var context1 = canvas1.getContext(&apos;2d&apos;);navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;var exArray = []; //存储设备源IDMediaStreamTrack.getSources(function (sourceInfos) &#123; for (var i = 0; i != sourceInfos.length; ++i) &#123; var sourceInfo = sourceInfos[i]; //这里会遍历audio,video，所以要加以区分 if (sourceInfo.kind === &apos;video&apos;) &#123; exArray.push(sourceInfo.id); &#125; &#125;&#125;);function getMedia() &#123; if (navigator.getUserMedia) &#123; navigator.getUserMedia(&#123; &apos;video&apos;: &#123; &apos;optional&apos;: [&#123; &apos;sourceId&apos;: exArray[1] //0为前置摄像头，1为后置 &#125;] &#125;, &apos;audio&apos;:true &#125;, successFunc, errorFunc); //success是获取成功的回调函数 &#125; else &#123; alert(&apos;Native device media streaming (getUserMedia) not supported in this browser.&apos;); &#125;&#125;function successFunc(stream) &#123; //alert(&apos;Succeed to get media!&apos;); if (video.mozSrcObject !== undefined) &#123; //Firefox中，video.mozSrcObject最初为null，而不是未定义的，我们可以靠这个来检测Firefox的支持 video.mozSrcObject = stream; &#125; else &#123; video.src = window.URL &amp;&amp; window.URL.createObjectURL(stream) || stream; &#125; //video.play(); // 音频 audio = new Audio(); audioType = getAudioType(audio); if (audioType) &#123; audio.src = &apos;polaroid.&apos; + audioType; audio.play(); &#125;&#125;function errorFunc(e) &#123; alert(&apos;Error！&apos;+e);&#125;//获取音频格式function getAudioType(element) &#123; if (element.canPlayType) &#123; if (element.canPlayType(&apos;audio/mp4; codecs=&quot;mp4a.40.5&quot;&apos;) !== &apos;&apos;) &#123; return (&apos;aac&apos;); &#125; else if (element.canPlayType(&apos;audio/ogg; codecs=&quot;vorbis&quot;&apos;) !== &apos;&apos;) &#123; return (&quot;ogg&quot;); &#125; &#125; return false;&#125;//拍照function getPhoto() &#123; context1.drawImage(video, 0, 0,220,220); //将video对象内指定的区域捕捉绘制到画布上指定的区域，实现拍照。 var face = $(&apos;#face&apos;) var canvas1 = document.getElementById(&apos;canvas1&apos;); face.val(canvas1.toDataURL(&apos;image/png&apos;))&#125; #templates/login.html(登陆界面)123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录&lt;/title&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.0.0.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;摄像&quot; onclick=&quot;getMedia()&quot;&gt; &lt;video src=&quot;&quot; autoplay=&quot;autoplay&quot; height=&quot;120px&quot;&gt;&lt;/video&gt; &lt;canvas id=&quot;canvas1&quot; height=&quot;220px&quot; width=&quot;200&quot;&gt;&lt;/canvas&gt; &lt;input type=&quot;button&quot; value=&quot;拍照&quot; height=&quot;120px&quot; onclick=&quot;getPhoto();&quot;&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; id=&quot;face&quot; name=&quot;face_img&quot;&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/p&gt; &lt;/form&gt; &lt;script src=&quot;&#123;&#123; static_url(&apos;js/ai.js&apos;) &#125;&#125;&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; #templates/register.html(注册界面)1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;注册&lt;/title&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.0.0.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;摄像&quot; onclick=&quot;getMedia()&quot;&gt; &lt;video src=&quot;&quot; autoplay=&quot;autoplay&quot; height=&quot;120px&quot;&gt;&lt;/video&gt; &lt;canvas id=&quot;canvas1&quot; height=&quot;220px&quot; width=&quot;200&quot;&gt;&lt;/canvas&gt; &lt;input type=&quot;button&quot; value=&quot;拍照&quot; height=&quot;120px&quot; onclick=&quot;getPhoto();&quot;&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; id=&quot;face&quot; name=&quot;face_img&quot;&gt; &lt;p&gt;账号： &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/p&gt; &lt;p&gt;真实姓名： &lt;input type=&quot;text&quot; name=&quot;realname&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/p&gt; &lt;/form&gt; &lt;script src=&quot;&#123;&#123; static_url(&apos;js/ai.js&apos;) &#125;&#125;&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; #untils/conn.py123456789101112131415161718from sqlalchemy import create_enginefrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy.orm import sessionmaker# 连接数据库格式# mysql+pymysql://root:123456@127.0.0.1:3306/tornado9db_url = &apos;mysql+pymysql://root:DENG5rong2hua0!@127.0.0.1:3306/tornado9&apos;# 创建引擎，建立连接engine = create_engine(db_url)# 模型与数据库表进行关联的基类，模型必须继承于BaseBase = declarative_base(bind=engine)# 创建session会话DbSession = sessionmaker(bind=engine)session = DbSession() #untils/faceid.py123456789101112131415161718192021from aip import AipFace&quot;&quot;&quot; 你的 APPID AK SK &quot;&quot;&quot;APP_ID = &apos;15752252&apos;API_KEY = &apos;IwwxkcwUr6TBUYCfhCHD97e4&apos;SECRET_KEY = &apos;fKyhxKGR6P1XlP6iXfGzlVajagViHdgt&apos;client = AipFace(APP_ID, API_KEY, SECRET_KEY)def face_register(image,userId,imageType=&apos;BASE64&apos;,groupId=&apos;user&apos;): res = client.addUser(image, imageType,groupId,userId) if res[&apos;error_code&apos;]: return False return Truedef face_login(image, imageType = &apos;BASE64&apos;, groupId = &apos;user&apos;): res = client.search(image,imageType,groupId) # print(res) if res[&apos;error_code&apos;]: return False return True","categories":[],"tags":[]},{"title":"MySQL 基础","slug":"MySQL","date":"2018-02-25T09:25:30.000Z","updated":"2019-02-25T10:02:18.053Z","comments":true,"path":"2018/02/25/MySQL/","link":"","permalink":"http://yoursite.com/2018/02/25/MySQL/","excerpt":"","text":"– SQL语法– DDL(数据定义语言)– DML(数据操作语言）– DCL(数据控制语言)– 注意: SQL中大小写不敏感（大写和小写是一样的）; 每条SQL语句必须以分号结束 – 一.DDL - 主要提供数据库和表的创建、删除和修改– 0. 删除数据库: drop database 数据库名;DROP DATABASE school; – 直接删除指定数据库DROP DATABASE if EXISTS school; – 如果指定的数据库存在就删除数据库 – 1.创建数据库: create database 数据库名;create database school; – 直接创建指定数据库CREATE database if not EXISTS school; – 当指定数据库不存在的时候才创建数据库create database if not EXISTS school default charset utf8; – 创建数据库的时候设置字符集编码方式为utf8,让数据库支持中文数据的存储 – 2.使用/切换数据库: use 数据库名;use school; – 3.新建表: create table if not exists 表名(字段名1 类型1, 字段2 类型2,…);– 注意： a. 表名一般需要加前缀’t’或者’tb’ b.字段用来确定表中要存储哪些数据，字段名随便命名但是不能是关键字 c.数据类型必须是MySQL支持的数据类型– 常用数据类型: int-整数, char(size)-定长字符串, varchar(size)-不定长字符串, text-字符串, bit-布尔, date-日期CREATE TABLE if not EXISTS t_student(stuid int, stuname varchar(20), gender bit, birth date); – 新建表并且添加约束: create table if not exists 表名(字段名1 类型1 约束1, 字段2 类型2 约束2,…);– 常见约束: not null - 不为空, default - 设置默认值, unique - 值唯一, primary key - 主键约束– 主键约束: 主键的值可以确定列表中唯一一条记录(通过一个主键值可以找到表中的唯一一条记录)– 注意: auto_increment只针对主键有效,并且主键的类型是整型;CREATE TABLE if not EXISTS t_student(stuid int not null auto_increment,stuname varchar(20) not null,gender bit DEFAULT 1,birth date,PRIMARY KEY(stuid) – 将字段stuid作为当前表的主键（设置主键可以间接约束这个字段的值是唯一的）); – 4.删除表: DROP TABLE if EXISTS 表名;DROP TABLE if EXISTS t_student;– 清空表中的数据: TRUNCATE TABLE 表名;TRUNCATE TABLE t_student; – 5.修改表– 5.1 添加列: alter TABLE 表名 add COLUMN 字段名 字段类型 约束;alter TABLE t_student add COLUMN score FLOAT(8,2) DEFAULT 0; – 5.2 删除列: alter TABLE 表名 drop COLUMN 字段名;alter TABLE t_student drop COLUMN gender; – 二、DML(数据操作语言) - 主要针对数据库中数据的增、删、改、查– 1.增(添加数据/记录)– 1.1插入数据/记录: insert into 表名 values(值1, 值2, 值3,….) - 依次给指定表中的字段赋值INSERT into t_student VALUES(100, ‘张三’, 0, ‘2019-9-23’); – 1.2插入数据/记录: insert into 表名(字段名1,字段名2,…) values(值1, 值2,…) -以指定的顺序给指定的字段赋值INSERT into t_student(stuname, birth) VALUES(“小花”, date(now())); – 一次插入一条记录 – 一次插入多条记录INSERT into t_student(stuname, birth) VALUES(“小花”, date(now())),(‘小明’, ‘2018-9-8’),(‘路飞’, ‘1999-12-16’),(‘佐助’, ‘2000-10-12’); – 值的问题: sql中是数字对应的值直接写，字符串需要使用引号引起来，bit类型的值只有0或者1, 时间可以用内容是满足时间格式字符串也可以是通过时间函数获取的值– 时间函数: now() - 当前时间 date(now()) - 当前日期 year(now()) - 当前年 month(now()) - 当前月 …. – 2.删（删除数据/记录）– delete from 表名; - 删除指定表中所有记录DELETE FROM t_student; – delete from 表名 where 条件语句; - 删除满足条件的记录– SQL中的条件语句: =(判断是否相等), &lt;&gt;(不等于,和python中的!=功能一样), &gt;, &lt;, &gt;=, &lt;=DELETE FROM t_student WHERE stuid=100; – 删除t_student表中stuid的值等于100的记录DELETE FROM t_student WHERE stuname=’小花’; – 删除t_student表中stuname的值等于’小花’的记录DELETE FROM t_student WHERE stuid&lt;108; – 删除t_student表中stuid的值小于’小花’的记录 – 3.改(修改数据/记录)– update 表名 set 字段1=新值1, 字段2=新值2,…; - 将指定表中所有行的指定列/字段的值赋值为新值UPDATE t_student set birth=’1999-10-1’, gender=1; – update 表名 set 字段1=新值1, 字段2=新值2,… where 条件语句; -将表中满足条件的行中指定字段的值赋值为新值UPDATE t_student set gender=0 WHERE stuname=’小花’; – 通配符%: 表示任意个数的任意字符（包括0个）UPDATE t_student set birth=’2000-01-01’ WHERE stuname LIKE ‘小%’; – 修改stuname是以’小’开头的行对应的birth的值UPDATE t_student set birth=’2111-01-01’ WHERE stuname LIKE ‘%小%’;– 统配符_: 表示一个任意字符UPDATE t_student set birth=’2444-01-01’ WHERE stuname LIKE ‘小_’; – 修改stuname只有两个字符，并且第一个字符是‘小’对应的行的birth的值– 注意: 通配符只针对字符串有效! – 4.查(获取数据)– 4.1直接查询– select from 表名; - 获取指定表中所有行和所有的列(所有数据)SELECT FROM t_student; – select 字段名1,字段名2,… from 表名; - 获取指定表中所有行指定的列SELECT stuname,stuid FROM t_student; – select from 表名 where 条件; - 获取指定表中所有满足条件的行所有列的数据SELECT FROM t_student WHERE stuid&gt;115; – 4.2列重命名– select 字段1 as 新字段1, 字段2 as 新字段2,… from 表名;– 注意： 这儿的as可以省略SELECT stuid as ‘学号’, stuname, gender as ‘性别’ FROM t_student; – 对查询结果中的stuid和gender字段进行重命名 – 4.3对查询结果重新赋值(一般针对布尔数据)– select if(字段名,值1,值2) from 表名; -查询指定字段，并且判断字段对应的值是0还是1，如果是1结果为值1，否则为值2– 注意: 这儿的if的用法是MySQL专有的– MySQL写法: if(字段, 新值1, 新值2)SELECT stuname,if(gender,’男’,’女’) as ‘性别’ FROM t_student;– 通用写法: case 字段 when 值 then 新值1 else 新值2 endSELECT case gender WHEN 1 THEN ‘男’ ELSE ‘女’ END as ‘性别’ FROM t_student; – 4.4对列进行合并– select concat(字段1,字段2,…) from 表名;SELECT CONCAT(stuname,stuid) as ‘name_id’ FROM t_student;SELECT CONCAT(stuname,’:’,stuid) as ‘name_id’ FROM t_student;– 注意: 数字和字符串数据可以合并，bit类型的数据不可以合并– SELECT CONCAT(stuname,’:’,gender) as ‘name_id’ FROM t_student; – 4.5模糊查询 - 查询的时候时候通过like条件来指定查询对象– sql中支持逻辑运算符and(逻辑与运算)和or(逻辑或运算)，not(逻辑非)SELECT * FROM t_student WHERE stuname like ‘%飞%’ or not stuid &lt; 110; – 4.6排序(先按之前的任何语法进行查询在排序)– select from 表名 order by 字段; - 对查询结果按照指定字段的值进行升序排序– select from 表名 order by 字段 asc; - 对查询结果按照指定字段的值进行升序排序– select from 表名 order by 字段 desc; - 对查询结果按照指定字段的值进行降序排序SELECT FROM t_student ORDER BY gender; – 按性别升序排序SELECT FROM t_student ORDER BY stuid ASC; – 按学号升序排序SELECT FROM t_student ORDER BY stuid DESC; – 按学号降序排序 – 排序的时候可以通过在order by的后边加多个字段，进行联排。排序的时候前面的字段的优先级高些SELECT * FROM t_student ORDER BY gender ASC, stuid DESC; – 先按性别进行升序排序，然后再按学号降序排序。 – 4.7限制– select from 表名 limit N; – 获取查询结果的前N条记录SELECT FROM t_student LIMIT 3; – 获取查询结果的前3条记录 – select from 表名 limit M offset N; – 对查询结果跳过前N条数据，取M条数据出来SELECT FROM t_student LIMIT 3 offset 4; – 跳过前4数据，然后取3条数据","categories":[],"tags":[]}]}